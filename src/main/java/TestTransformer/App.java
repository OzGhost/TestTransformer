/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package TestTransformer;

import subject.*;
import java.io.*;
import java.util.*;
import java.util.stream.*;
import com.github.javaparser.*;
import com.github.javaparser.ast.*;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.expr.*;
import com.github.javaparser.ast.stmt.*;

public class App {

    private OutputStream os;

    public int getVal() {
        Storage.reset();
        StaticSubject.noRefun();
        NonStaticSubject nss = NonStaticSubject.create();
        nss.noReturn();
        return StaticSubject.getRefun() + nss.val() + Storage.feed + Storage.foo;
    }

    public static void main(String[] args) throws Exception {
        new App().transform();
    }

    public void transform() throws Exception {
        CompilationUnit cUnit = StaticJavaParser.parse(new File("./src/test/java/TestTransformer/MockTest.java"));

        removeImportStartsWith(cUnit, "org.powermock");
        removeImportStartsWith(cUnit, "org.mockito");

        if (removePowerMockRunner(cUnit)) {
            removeImportStartsWith(cUnit, "org.junit.runner");
        }

        cUnit.addImport(new ImportDeclaration("mockit", false, true));

        for (ClassOrInterfaceDeclaration classUnit: cUnit.findAll(ClassOrInterfaceDeclaration.class)) {
            for (MethodDeclaration methodUnit: classUnit.findAll(MethodDeclaration.class)) {
                rebuildMethod(methodUnit);
            }
        }

        System.out.println(cUnit);
        //print(cUnit);
    }

    private void removeImportStartsWith(CompilationUnit cUnit, String importPrefix) {
        NodeList<ImportDeclaration> imports = cUnit.getImports();
        ArrayList<ImportDeclaration> useless = new ArrayList<>(imports.size());
        for (ImportDeclaration imp: imports) {
            String name = imp.getName().asString();
            if (name.startsWith(importPrefix)) {
                useless.add(imp);
            }
        }

        for (ImportDeclaration imp: useless) {
            imports.remove(imp);
        }
    }

    private boolean removePowerMockRunner(CompilationUnit cUnit) {
        boolean output = false;
        for (ClassOrInterfaceDeclaration classNode: cUnit.findAll(ClassOrInterfaceDeclaration.class)) {
            ArrayList<Node> useless = new ArrayList<>();
            for (Node cn: classNode.getChildNodes()) {
                if (cn instanceof SingleMemberAnnotationExpr) {
                    SingleMemberAnnotationExpr acn = (SingleMemberAnnotationExpr) cn;
                    String identifier = acn.getName().getIdentifier();
                    if ("RunWith".equals(identifier)) {
                        String mv = acn.getMemberValue().toString();
                        if ("PowerMockRunner.class".equals(mv)) {
                            output = true;
                            useless.add(cn);
                        }
                    } else if ("PrepareForTest".equals(identifier)){
                        output = true;
                        useless.add(cn);
                    }
                }
            }
            for (Node un: useless) {
                classNode.remove(un);
            }
        }
        return output;
    }

    private void rebuildMethod(MethodDeclaration method) {
        ArrayList<String> staticMocked = new ArrayList<>();
        LinkedList<Node> useless = new LinkedList<>();
        BlockStmt methodBody = method.getBody().get();
        for (Statement stmt: methodBody.getStatements()) {
            for (MethodCallExpr call: stmt.findAll(MethodCallExpr.class)) {
                if ("mockStatic".equals(call.getName().asString())) {
                    for (Expression ex: call.getArguments()) {
                        String className = ex.toString();
                        staticMocked.add(className.substring(0, className.lastIndexOf('.')));
                    }
                    useless.push(stmt);
                }
            }
        }
        staticMocked.forEach(e -> System.out.println("-->>> " + e));
        while ( ! useless.isEmpty()) {
            methodBody.remove(useless.pop());
        }

        for (Statement stm: methodBody.getStatements()) {
            if (stm.toString().contains("when")) {
                print(stm);
            }
        }
    }

    private void print(Node node) {
        try {
            this.os = new FileOutputStream(new File("/tmp/out"));
            print(node, 1);
            this.os.close();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void print(Node node, int deep) throws Exception {
        print(buildPrefix(deep) + " " + node.toString() + " :: " + node.getClass().toString() + "<<<<\n");
        int cdeep = deep + 1;
        for (Node child: node.getChildNodes()) {
            print(child, cdeep);
        }
    }

    private void print(String content) throws Exception {
        //this.os.write(content.getBytes());
        System.out.print(content);
    }

    private String buildPrefix(int len) {
        StringBuilder sb = new StringBuilder(len * 4);
        for (int i = 0; i < len; i++) {
            sb.append("   >");
        }
        return sb.toString();
    }
}
